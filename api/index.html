<!DOCTYPE html><!--

This page is automatically generated. See:
https://github.com/fortunejs/fortune/tree/master/website

--><meta charset="utf-8"><title>API Reference</title><link rel="icon" href="../assets/piggu.png"><link rel="stylesheet" href="../assets/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.perfect-scrollbar/0.6.12/css/perfect-scrollbar.min.css"><header><div><a href="../"><img src="../assets/fortune_logo.svg" alt="Fortune.js" class="logo-type"></a><a href="https://github.com/fortunejs/fortune" class="corner">GitHub<span> Repository</span></a></div></header><main><article><div class="api"><h6>Fortune <span>(<a href="https://github.com/fortunejs/fortune/blob/master/lib/core.js"><em>core.js</em></a>)</span></h6><h2 id="fortune"><span class="class">class</span> <!--
        --><!--
        --><!--
        -->Fortune<!--
        --><!--
        --><!--
        --><!--
        --><!--
        --><!--
      --><a href="#fortune" class="anchor">#</a></h2><p>This is the default export of the <code>fortune</code> package. It implements a <a href="https://www.npmjs.com/package/event-lite">subset of <code>EventEmitter</code></a>, and it has a few static properties attached to it that may be useful to access:</p><ul><li><code>Adapter</code>: abstract base class for the Adapter.</li><li><code>adapters</code>: included adapters, defaults to memory adapter. Note that the browser build also includes <code>indexedDB</code> and <code>webStorage</code> adapters.</li><li><code>net</code>: network protocol helpers, varies based on client or server build.</li><li><code>errors</code>: custom typed errors, useful for throwing errors in I/O hook functions.</li><li><code>methods</code>: a hash that maps to string constants. Available are: <code>find</code>, <code>create</code>, <code>update</code>, and <code>delete</code>.</li><li><code>events</code>: names for events on the Fortune instance.</li><li><code>message</code>: a function which accepts the arguments (<code>id</code>, <code>language</code>, <code>data</code>). It has properties keyed by two-letter language codes, which by default includes only <code>en</code>.</li><li><code>Promise</code>: by default, the native Promise implementation is used in the browser, or <a href="https://github.com/petkaantonov/bluebird/">Bluebird</a> in Node.js. If an alternative is desired, simply assign this property with the new Promise class. This will affect all instances of Fortune.</li></ul><h2 id="fortune-constructor"><span class="class">new</span> Fortune<!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="Object">recordTypes</span>, <span class="parameter" title="Object">[options]</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Fortune</span><!--
        --><!--
      --><a href="#fortune-constructor" class="anchor">#</a></h2><p>Create a new instance, the only required input is record type definitions. The first argument must be an object keyed by name, valued by definition objects.</p><p>Here are some example field definitions:</p><pre><code class="lang-js">{
  <span class="hljs-comment">// Top level keys are names of record types.</span>
  <span class="hljs-attribute">person</span>: {
    <span class="hljs-comment">// Data types may be singular or plural.</span>
    <span class="hljs-attribute">name</span>: String, <span class="hljs-comment">// Singular string value.</span>
    <span class="hljs-attribute">luckyNumbers</span>: Array(Number), <span class="hljs-comment">// Array of numbers.</span>

    <span class="hljs-comment">// Relationships may be singular or plural. They must specify which</span>
    <span class="hljs-comment">// record type it refers to, and may also specify an inverse field</span>
    <span class="hljs-comment">// which is optional but recommended.</span>
    <span class="hljs-attribute">pets</span>: [ Array(<span class="hljs-string">'animal'</span>), <span class="hljs-string">'owner'</span> ], <span class="hljs-comment">// Has many.</span>
    <span class="hljs-attribute">employer</span>: [ <span class="hljs-string">'organization'</span>, <span class="hljs-string">'employees'</span> ], <span class="hljs-comment">// Belongs to.</span>
    <span class="hljs-attribute">likes</span>: Array(<span class="hljs-string">'thing'</span>), <span class="hljs-comment">// Has many (no inverse).</span>
    <span class="hljs-attribute">doing</span>: <span class="hljs-string">'activity'</span>, <span class="hljs-comment">// Belongs to (no inverse).</span>

    <span class="hljs-comment">// Reflexive relationships are relationships in which the record type,</span>
    <span class="hljs-comment">// the first position, is of the same type.</span>
    <span class="hljs-attribute">following</span>: [ Array(<span class="hljs-string">'person'</span>), <span class="hljs-string">'followers'</span> ],
    <span class="hljs-attribute">followers</span>: [ Array(<span class="hljs-string">'person'</span>), <span class="hljs-string">'following'</span> ],

    <span class="hljs-comment">// Mutual relationships are relationships in which the inverse,</span>
    <span class="hljs-comment">// the second position, is defined to be the same field on the same</span>
    <span class="hljs-comment">// record type.</span>
    <span class="hljs-attribute">friends</span>: [ Array(<span class="hljs-string">'person'</span>), <span class="hljs-string">'friends'</span> ],
    <span class="hljs-attribute">spouse</span>: [ <span class="hljs-string">'person'</span>, <span class="hljs-string">'spouse'</span> ]
  }
}
</code></pre><p>The above shows the shorthand which will be transformed internally to a more verbose data structure. The internal structure is as follows:</p><pre><code class="lang-js">{
  <span class="hljs-attribute">person</span>: {
    <span class="hljs-comment">// A singular value.</span>
    <span class="hljs-attribute">name</span>: { <span class="hljs-attribute">type</span>: String },

    <span class="hljs-comment">// An array containing values of a single type.</span>
    <span class="hljs-attribute">luckyNumbers</span>: { <span class="hljs-attribute">type</span>: Number, <span class="hljs-attribute">isArray</span>: true },

    <span class="hljs-comment">// Creates a to-many link to `animal` record type. If the field `owner`</span>
    <span class="hljs-comment">// on the `animal` record type is not an array, this is a many-to-one</span>
    <span class="hljs-comment">// relationship, otherwise it is many-to-many.</span>
    <span class="hljs-attribute">pets</span>: { <span class="hljs-attribute">link</span>: <span class="hljs-string">'animal'</span>, <span class="hljs-attribute">isArray</span>: true, <span class="hljs-attribute">inverse</span>: <span class="hljs-string">'owner'</span> },

    <span class="hljs-comment">// The `min` and `max` keys are open to interpretation by the specific</span>
    <span class="hljs-comment">// adapter, which may introspect the field definition.</span>
    <span class="hljs-attribute">thing</span>: { <span class="hljs-attribute">type</span>: Number, <span class="hljs-attribute">min</span>: <span class="hljs-number">0</span>, <span class="hljs-attribute">max</span>: <span class="hljs-number">100</span> },

    <span class="hljs-comment">// Nested field definitions are invalid. Use `Object` type instead.</span>
    <span class="hljs-attribute">nested</span>: { <span class="hljs-attribute">thing</span>: { ... } } <span class="hljs-comment">// Will throw an error.</span>
  }
}
</code></pre><p>The allowed native types are <code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Date</code>, <code>Object</code>, and <code>Buffer</code>. Note that the <code>Object</code> type should be a JSON serializable object that may be persisted. The only other allowed type is a <code>Function</code>, which may be used to define custom types.</p><p>A custom type function should accept one argument, the value, and return a boolean based on whether the value is valid for the type or not. It may optionally have a method <code>compare</code>, used for sorting in the built-in adapters. The <code>compare</code> method should have the same signature as the native <code>Array.prototype.sort</code>.</p><p>A custom type function must inherit one of the allowed native types. For example:</p><pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword">Integer</span> (x) { <span class="hljs-keyword">return</span> (x | <span class="hljs-number">0</span>) === x }
<span class="hljs-keyword">Integer</span>.prototype = Object.create(<span class="hljs-keyword">Number</span>.prototype)
</code></pre><p>The options object may contain the following keys:</p><ul><li><p><code>adapter</code>: configuration array for the adapter. The default type is the memory adapter. If the value is not an array, its settings will be considered omitted.</p><pre><code class="lang-js">{
  adapter: <span class="hljs-meta">[</span>
    <span class="hljs-comment">// Must be a class that extends `Fortune.Adapter`, or a function</span>
    <span class="hljs-comment">// that accepts the Adapter class and returns a subclass. Required.</span>
    Adapter =&gt; { <span class="hljs-params">...</span> },

    <span class="hljs-comment">// An options object that is specific to the adapter. Optional.</span>
    { <span class="hljs-params">...</span> }
  <span class="hljs-meta">]</span>
}
</code></pre></li><li><p><code>hooks</code>: keyed by type name, valued by an array containing an <code>input</code> and/or <code>output</code> function at indices <code>0</code> and <code>1</code> respectively.</p><p>A hook function takes at least two arguments, the internal <code>context</code> object and a single <code>record</code>. A special case is the <code>update</code> argument for the <code>update</code> method.</p><p>There are only two kinds of hooks, before a record is written (input), and after a record is read (output), both are optional. If an error occurs within a hook function, it will be forwarded to the response. Use typed errors to provide the appropriate feedback.</p><p>For a create request, the input hook may return the second argument <code>record</code> either synchronously, or asynchronously as a Promise. The return value of a delete request is inconsequential, but it may return a value or a Promise. The <code>update</code> method accepts a <code>update</code> object as a third parameter, which may be returned synchronously or as a Promise.</p><p>An example hook to apply a timestamp on a record before creation, and displaying the timestamp in the server&#39;s locale:</p><pre><code class="lang-js">{
  recordType: [
    (context, <span class="hljs-keyword">record</span>, update) =&gt; {
      switch (context.request.method) {
        <span class="hljs-keyword">case</span> <span class="hljs-symbol">'create</span>':
          <span class="hljs-keyword">record</span>.timestamp = <span class="hljs-keyword">new</span> Date()
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">record</span>
        <span class="hljs-keyword">case</span> <span class="hljs-symbol">'update</span>': <span class="hljs-keyword">return</span> update
        <span class="hljs-keyword">case</span> <span class="hljs-symbol">'delete</span>': <span class="hljs-keyword">return</span> null
      }
    },
    (context, <span class="hljs-keyword">record</span>) =&gt; {
      <span class="hljs-keyword">record</span>.timestamp = <span class="hljs-keyword">record</span>.timestamp.toLocaleString()
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">record</span>
    }
  ]
}
</code></pre><p>Requests to update a record will <strong>NOT</strong> have the updates already applied to the record.</p><p>Another feature of the input hook is that it will have access to a temporary field <code>context.transaction</code>. This is useful for ensuring that bulk write operations are all or nothing. Each request is treated as a single transaction.</p></li><li><p><code>documentation</code>: an object mapping names to descriptions. Note that there is only one namepspace, so field names can only have one description. This is optional, but useful for the HTML serializer, which also emits this information as micro-data.</p><pre><code class="lang-js">{
  <span class="hljs-attribute">documentation</span>: {
    <span class="hljs-attribute">recordType</span>: <span class="hljs-string">'Description of a type.'</span>,
    <span class="hljs-attribute">fieldName</span>: <span class="hljs-string">'Description of a field.'</span>,
    <span class="hljs-attribute">anotherFieldName</span>: {
      <span class="hljs-attribute">en</span>: <span class="hljs-string">'Two letter language code indicates localized description.'</span>
    }
  }
}
</code></pre></li><li><p><code>settings</code>: internal settings to configure.</p><pre><code class="lang-js">{
  settings: {
    // Whether <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> to enforce referential integrity. Default: `<span class="hljs-literal">true</span>`
    // <span class="hljs-keyword">for</span> server, `<span class="hljs-literal">false</span>` <span class="hljs-keyword">for</span> browser.
    enforceLinks: <span class="hljs-literal">true</span>,

    // Name <span class="hljs-keyword">of</span> the application used <span class="hljs-keyword">for</span> display purposes.
    name: <span class="hljs-symbol">'My</span> Awesome Application',

    // Description <span class="hljs-keyword">of</span> the application used <span class="hljs-keyword">for</span> display purposes.
    description: <span class="hljs-symbol">'media</span> <span class="hljs-keyword">type</span> <span class="hljs-type">"application/vnd.micro+json"'
  </span>}
}
</code></pre></li></ul><p>The return value of the constructor is the instance itself.</p><h2 id="fortune-request"><!--
        --><!--
        --><!--
        --><!--
        -->Fortune.<span class="key">request</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="Object">options</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise</span><!--
        --><!--
      --><a href="#fortune-request" class="anchor">#</a></h2><p>This is the primary method for initiating a request. The options object may contain the following keys:</p><ul><li><p><code>method</code>: The method is a either a function or a constant, which is keyed under <code>Fortune.methods</code> and may be one of <code>find</code>, <code>create</code>, <code>update</code>, or <code>delete</code>. Default: <code>find</code>.</p></li><li><p><code>type</code>: Name of a type. <strong>Required</strong>.</p></li><li><p><code>ids</code>: An array of IDs. Used for <code>find</code> and <code>delete</code> methods only. This is optional for the <code>find</code> method.</p></li><li><p><code>include</code>: A 2-dimensional array specifying links to include. The first dimension is a list, the second dimension is depth. For example: <code>[[&#39;comments&#39;], [&#39;comments&#39;, &#39;author&#39;, { ... }]]</code>. The last item within the list may be an <code>options</code> object, useful for specifying how the included records should appear. Optional.</p></li><li><p><code>options</code>: Exactly the same as the <a href="#adapter-find"><code>find</code> method</a> options in the adapter. These options do not apply on methods other than <code>find</code>, and do not affect the records returned from <code>include</code>. Optional.</p></li><li><p><code>meta</code>: Meta-information object of the request. Optional.</p></li><li><p><code>payload</code>: Payload of the request. <strong>Required</strong> for <code>create</code> and <code>update</code> methods only, and must be an array of objects. The objects must be the records to create, or update objects as expected by the Adapter.</p></li></ul><p>The response object may contain the following keys:</p><ul><li><p><code>meta</code>: Meta-info of the response.</p></li><li><p><code>payload</code>: An object containing the following keys:</p><ul><li><code>records</code>: An array of records returned.</li><li><code>count</code>: Total number of records without options applied (only for responses to the <code>find</code> method).</li><li><code>include</code>: An object keyed by type, valued by arrays of included records.</li></ul></li></ul><p>The resolved response object should always be an instance of a response type.</p><h2 id="fortune-find"><!--
        --><!--
        --><!--
        --><!--
        -->Fortune.<span class="key">find</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="String">type</span>, <span class="parameter" title="Either any type, or an array of any types">[ids]</span>, <span class="parameter" title="Object">[options]</span>, <span class="parameter" title="Array of Arrays">[include]</span>, <span class="parameter" title="Object">[meta]</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise</span><!--
        --><!--
      --><a href="#fortune-find" class="anchor">#</a></h2><p>The <code>find</code> method retrieves record by type given IDs, querying options, or both. This is a convenience method that wraps around the <code>request</code> method, see the <code>request</code> method for documentation on its arguments.</p><h2 id="fortune-create"><!--
        --><!--
        --><!--
        --><!--
        -->Fortune.<span class="key">create</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="String">type</span>, <span class="parameter" title="Either Object, or an array of Objects">records</span>, <span class="parameter" title="Array of Arrays">[include]</span>, <span class="parameter" title="Object">[meta]</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise</span><!--
        --><!--
      --><a href="#fortune-create" class="anchor">#</a></h2><p>The <code>create</code> method creates records by type given records to create. This is a convenience method that wraps around the <code>request</code> method, see the request <code>method</code> for documentation on its arguments.</p><h2 id="fortune-update"><!--
        --><!--
        --><!--
        --><!--
        -->Fortune.<span class="key">update</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="String">type</span>, <span class="parameter" title="Either Object, or an array of Objects">updates</span>, <span class="parameter" title="Array of Arrays">[include]</span>, <span class="parameter" title="Object">[meta]</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise</span><!--
        --><!--
      --><a href="#fortune-update" class="anchor">#</a></h2><p>The <code>update</code> method updates records by type given update objects. See the <a href="#adapter-update">Adapter.update</a> method for the format of the update objects. This is a convenience method that wraps around the <code>request</code> method, see the <code>request</code> method for documentation on its arguments.</p><h2 id="fortune-delete"><!--
        --><!--
        --><!--
        --><!--
        -->Fortune.<span class="key">delete</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="String">type</span>, <span class="parameter" title="Either any type, or an array of any types">[ids]</span>, <span class="parameter" title="Array of Arrays">[include]</span>, <span class="parameter" title="Object">[meta]</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise</span><!--
        --><!--
      --><a href="#fortune-delete" class="anchor">#</a></h2><p>The <code>delete</code> method deletes records by type given IDs (optional). This is a convenience method that wraps around the <code>request</code> method, see the <code>request</code> method for documentation on its arguments.</p><h2 id="fortune-connect"><!--
        --><!--
        --><!--
        --><!--
        -->Fortune.<span class="key">connect</span><!--
        --><!--
        --><!--
        --><!--
          -->()<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise</span><!--
        --><!--
      --><a href="#fortune-connect" class="anchor">#</a></h2><p>This method does not need to be called manually, it is automatically called upon the first request if it is not connected already. However, it may be useful if manually reconnect is needed. The resolved value is the instance itself.</p><h2 id="fortune-disconnect"><!--
        --><!--
        --><!--
        --><!--
        -->Fortune.<span class="key">disconnect</span><!--
        --><!--
        --><!--
        --><!--
          -->()<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise</span><!--
        --><!--
      --><a href="#fortune-disconnect" class="anchor">#</a></h2><p>Close adapter connection, and reset connection state. The resolved value is the instance itself.</p><hr><h6>Adapter <span>(<a href="https://github.com/fortunejs/fortune/blob/master/lib/adapter&#x2F;index.js"><em>adapter&#x2F;index.js</em></a>)</span></h6><h2 id="adapter"><span class="class">class</span> <!--
        --><!--
        --><!--
        -->Adapter<!--
        --><!--
        --><!--
        --><!--
        --><!--
        --><!--
      --><a href="#adapter" class="anchor">#</a></h2><p>Adapter is an abstract base class containing methods to be implemented. All records returned by the adapter must have the primary key <code>id</code>. The primary key <strong>MUST</strong> be a string or a number.</p><h2 id="adapter-constructor"><span class="class">new</span> Adapter<!--
        --><!--
        --><!--
        --><!--
          -->()<!--
        --><!--
        --><!--
      --><a href="#adapter-constructor" class="anchor">#</a></h2><p>The Adapter should not be instantiated directly, since the constructor function accepts dependencies. The keys which are injected are:</p><ul><li><code>methods</code>: same as static property on Fortune class.</li><li><code>errors</code>: same as static property on Fortune class.</li><li><code>keys</code>: an object which enumerates reserved constants for record type definitions.</li><li><code>recordTypes</code>: an object which enumerates record types and their definitions.</li><li><code>options</code>: the options passed to the adapter.</li><li><code>message</code>: a function with the signature (<code>id</code>, <code>language</code>, <code>data</code>).</li><li><code>Promise</code>: the Promise implementation.</li></ul><p>These keys are accessible on the instance (<code>this</code>).</p><h2 id="adapter-connect"><!--
        --><!--
        --><!--
        --><!--
        -->Adapter.<span class="key">connect</span><!--
        --><!--
        --><!--
        --><!--
          -->()<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise</span><!--
        --><!--
      --><a href="#adapter-connect" class="anchor">#</a></h2><p>The responsibility of this method is to ensure that the record types defined are consistent with the backing data store. If there is any mismatch it should either try to reconcile differences or fail. This method <strong>SHOULD NOT</strong> be called manually, and it should not accept any parameters. This is the time to do setup tasks like create tables, ensure indexes, etc. On successful completion, it should resolve to no value.</p><h2 id="adapter-disconnect"><!--
        --><!--
        --><!--
        --><!--
        -->Adapter.<span class="key">disconnect</span><!--
        --><!--
        --><!--
        --><!--
          -->()<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise</span><!--
        --><!--
      --><a href="#adapter-disconnect" class="anchor">#</a></h2><p>Close the database connection.</p><h2 id="adapter-create"><!--
        --><!--
        --><!--
        --><!--
        -->Adapter.<span class="key">create</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="String">type</span>, <span class="parameter" title="Array of Objects">records</span>, <span class="parameter" title="Object">[meta]</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise</span><!--
        --><!--
      --><a href="#adapter-create" class="anchor">#</a></h2><p>Create records. A successful response resolves to the newly created records.</p><p><strong>IMPORTANT</strong>: the record must have initial values for each field defined in the record type. For non-array fields, it should be <code>null</code>, and for array fields it should be <code>[]</code> (empty array). Note that not all fields in the record type may be enumerable, such as denormalized inverse fields, so it may be necessary to iterate over fields using <code>Object.getOwnPropertyNames</code>.</p><h2 id="adapter-find"><!--
        --><!--
        --><!--
        --><!--
        -->Adapter.<span class="key">find</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="String">type</span>, <span class="parameter" title="Either an array of Strings, or an array of Numbers">[ids]</span>, <span class="parameter" title="Object">[options]</span>, <span class="parameter" title="Object">[meta]</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise</span><!--
        --><!--
      --><a href="#adapter-find" class="anchor">#</a></h2><p>Find records by IDs and options. If IDs is undefined, it should try to return all records. However, if IDs is an empty array, it should be a no-op. The format of the options may be as follows:</p><pre><code class="lang-js">{
<span class="hljs-symbol">  sort:</span> { ... },
<span class="hljs-symbol">  fields:</span> { ... },
<span class="hljs-symbol">  exists:</span> { ... },
<span class="hljs-symbol">  match:</span> { ... },
<span class="hljs-symbol">  range:</span> { ... },

  <span class="hljs-comment">// Limit results to this number. Zero means no limit.</span>
<span class="hljs-symbol">  limit:</span> <span class="hljs-number">0</span>,

  <span class="hljs-comment">// Offset results by this much from the beginning.</span>
<span class="hljs-symbol">  offset:</span> <span class="hljs-number">0</span>,

  <span class="hljs-comment">// Reserved field for custom querying.</span>
<span class="hljs-symbol">  query:</span> null
}
</code></pre><p>For the fields <code>exists</code>, <code>match</code>, and <code>range</code>, the logical operator should be &quot;and&quot;. The <code>query</code> field may be used on a per adapter basis to provide custom querying functionality.</p><p>The syntax of the <code>sort</code> object is as follows:</p><pre><code class="lang-js">{
  age: <span class="hljs-literal">false</span>, <span class="hljs-comment">// descending</span>
  <span class="hljs-built_in">name</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// ascending</span>
}
</code></pre><p>Fields can be specified to be either included or omitted, but not both. Use the values <code>true</code> to include, or <code>false</code> to omit. The syntax of the <code>fields</code> object is as follows:</p><pre><code class="lang-js">{
  <span class="hljs-built_in">name</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// include this field</span>
  age: <span class="hljs-literal">true</span> <span class="hljs-comment">// also include this field</span>
}
</code></pre><p>The <code>exists</code> object specifies if a field should exist or not (<code>true</code> or <code>false</code>). For array fields, it should check for non-zero length.</p><pre><code class="lang-js">{
  name: true, //<span class="hljs-built_in"> check </span>if this fields exists
  age: false //<span class="hljs-built_in"> check </span>if this field doesn't exist
}
</code></pre><p>The syntax of the <code>match</code> object is straightforward:</p><pre><code class="lang-js">{
  name: <span class="hljs-string">'value'</span>, // exact <span class="hljs-keyword">match</span> <span class="hljs-built_in">or</span> containment <span class="hljs-keyword">if</span> array
  friend<span class="hljs-variable">s:</span> [ <span class="hljs-string">'joe'</span>, <span class="hljs-string">'bob'</span> ] // <span class="hljs-keyword">match</span> any one of these <span class="hljs-built_in">values</span>
}
</code></pre><p>The <code>range</code> object is used to filter between lower and upper bounds. It should take precedence over <code>match</code>. For array fields, it should apply on the length of the array. For singular link fields, it should not apply.</p><pre><code class="lang-js">{
<span class="hljs-symbol">  range:</span> { <span class="hljs-comment">// Ranges should be inclusive.</span>
<span class="hljs-symbol">    age:</span> [ <span class="hljs-number">18</span>, null ], <span class="hljs-comment">// From 18 and above.</span>
<span class="hljs-symbol">    name:</span> [ <span class="hljs-string">'a'</span>, <span class="hljs-string">'d'</span> ], <span class="hljs-comment">// Starting with letters A through C.</span>
<span class="hljs-symbol">    createdAt:</span> [ null, new Date(<span class="hljs-number">2016</span>, <span class="hljs-number">0</span>) ] <span class="hljs-comment">// Dates until 2016.</span>
  }
}
</code></pre><p>The return value of the promise should be an array, and the array <strong>MUST</strong> have a <code>count</code> property that is the total number of records without limit and offset.</p><h2 id="adapter-update"><!--
        --><!--
        --><!--
        --><!--
        -->Adapter.<span class="key">update</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="String">type</span>, <span class="parameter" title="Array of Objects">updates</span>, <span class="parameter" title="Object">[meta]</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise</span><!--
        --><!--
      --><a href="#adapter-update" class="anchor">#</a></h2><p>Update records by IDs. Success should resolve to the number of records updated. The <code>updates</code> parameter should be an array of objects that correspond to updates by IDs. Each update object must be as follows:</p><pre><code class="lang-js">{
  <span class="hljs-comment">// ID to update. Required.</span>
  <span class="hljs-attribute">id</span>: <span class="hljs-number">1</span>,

  <span class="hljs-comment">// Replace a value of a field. Use a `null` value to unset a field.</span>
  <span class="hljs-attribute">replace</span>: { <span class="hljs-attribute">name</span>: <span class="hljs-string">'Bob'</span> },

  <span class="hljs-comment">// Append values to an array field. If the value is an array, all of</span>
  <span class="hljs-comment">// the values should be pushed.</span>
  <span class="hljs-attribute">push</span>: { <span class="hljs-attribute">pets</span>: <span class="hljs-number">1</span> },

  <span class="hljs-comment">// Remove values from an array field. If the value is an array, all of</span>
  <span class="hljs-comment">// the values should be removed.</span>
  <span class="hljs-attribute">pull</span>: { <span class="hljs-attribute">friends</span>: [ <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ] },

  <span class="hljs-comment">// The `operate` field is specific to the adapter. This should take</span>
  <span class="hljs-comment">// precedence over all of the above. Warning: using this may bypass</span>
  <span class="hljs-comment">// field definitions and referential integrity. Use at your own risk.</span>
  <span class="hljs-attribute">operate</span>: null
}
</code></pre><p>Things to consider:</p><ul><li><code>push</code> and <code>pull</code> can not be applied to non-arrays.</li><li>The same value in the same field should not exist in both <code>push</code> and <code>pull</code>.</li></ul><h2 id="adapter-delete"><!--
        --><!--
        --><!--
        --><!--
        -->Adapter.<span class="key">delete</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="String">type</span>, <span class="parameter" title="Either an array of Strings, or an array of Numbers">[ids]</span>, <span class="parameter" title="Object">[meta]</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise</span><!--
        --><!--
      --><a href="#adapter-delete" class="anchor">#</a></h2><p>Delete records by IDs, or delete the entire collection if IDs are undefined or empty. Success should resolve to the number of records deleted.</p><h2 id="adapter-begintransaction"><!--
        --><!--
        --><!--
        --><!--
        -->Adapter.<span class="key">beginTransaction</span><!--
        --><!--
        --><!--
        --><!--
          -->()<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise</span><!--
        --><!--
      --><a href="#adapter-begintransaction" class="anchor">#</a></h2><p>Begin a transaction to write to the data store. This method is optional to implement, but useful for ACID. It should resolve to an object containing all of the adapter methods.</p><h2 id="adapter-endtransaction"><!--
        --><!--
        --><!--
        --><!--
        -->Adapter.<span class="key">endTransaction</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="Error. If an error is passed, roll back the transaction.">[error]</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise</span><!--
        --><!--
      --><a href="#adapter-endtransaction" class="anchor">#</a></h2><p>End a transaction. This method is optional to implement. It should return a Promise with no value if the transaction is completed successfully, or reject the promise if it failed.</p><h2 id="adapter-applyoperators"><!--
        --><!--
        --><!--
        --><!--
        -->Adapter.<span class="key">applyOperators</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="Object">record</span>, <span class="parameter" title="Object. The `operate` field on an `update` object.">operators</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Object</span><!--
        --><!--
      --><a href="#adapter-applyoperators" class="anchor">#</a></h2><p>Apply operators on a record, then return the record. If you make use of update operators, you should implement this method so that the internal implementation of update requests get records in the correct state. This method is optional to implement.</p><hr><h6>HTTP Server <span>(<a href="https://github.com/fortunejs/fortune/blob/master/lib/net&#x2F;http_server.js"><em>net&#x2F;http_server.js</em></a>)</span></h6><h2 id="fortune.net-http"><!--
        --><!--
        --><!--
        --><!--
        -->Fortune.net.<span class="key">http</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="Fortune">instance</span>, <span class="parameter" title="Object">[options]</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Function</span><!--
        --><!--
      --><a href="#fortune.net-http" class="anchor">#</a></h2><p><strong>Node.js only</strong>: This function implements a HTTP server for Fortune, it&#39;s a static method available at <code>Fortune.net.http</code>. The integration with Fortune is minimal: it determines which serializer to use, assigns request headers to the <code>meta</code> object, reads the request body, and maps the response from the <code>request</code> method on to the HTTP response. The listener function ends the response and returns a promise that is resolved when the response is ended. The returned promise may be rejected with the error response, providing a hook for error logging.</p><p>The options object may be formatted as follows:</p><pre><code class="lang-js">{
  <span class="hljs-comment">// An array of HTTP serializers, ordered by priority. Defaults to ad hoc</span>
  <span class="hljs-comment">// JSON and form serializers if none are specified. If a serializer value</span>
  <span class="hljs-comment">// is not an array, its settings will be considered omitted.</span>
<span class="hljs-symbol">  serializers:</span> [
    [
      <span class="hljs-comment">// A function that subclasses the HTTP Serializer.</span>
      HttpSerializerSubclass,

      <span class="hljs-comment">// Settings to pass to the constructor, optional.</span>
      { ... }
    ]
  ],
<span class="hljs-symbol">  settings:</span> {
    <span class="hljs-comment">// By default, the listener will end the response, set this to `false`</span>
    <span class="hljs-comment">// if the response will be ended later.</span>
<span class="hljs-symbol">    endResponse:</span> true,

    <span class="hljs-comment">// Use compression if the request `Accept-Encoding` header allows it.</span>
    <span class="hljs-comment">// Note that Buffer-typed responses will not be compressed. This option</span>
    <span class="hljs-comment">// should be disabled in case of a reverse proxy which handles</span>
    <span class="hljs-comment">// compression.</span>
<span class="hljs-symbol">    useCompression:</span> true,

    <span class="hljs-comment">// Use built-in ETag implementation, which uses CRC32 under the hood.</span>
    <span class="hljs-comment">// This option should be disabled in case of a reverse proxy which</span>
    <span class="hljs-comment">// handles compression.</span>
<span class="hljs-symbol">    useETag:</span> true
  }
}
</code></pre><p>The <code>http</code> function object contains the following keys:</p><ul><li><code>Serializer</code>: HTTP Serializer class.</li><li><code>JsonSerializer</code>: JSON over HTTP serializer.</li><li><code>HtmlSerializer</code>: HTML serializer.</li><li><code>FormDataSerializer</code>: Serializer for <code>multipart/formdata</code>.</li><li><code>FormUrlEncodedSerializer</code>: Serializer for <code>application/x-www-form-urlencoded</code>.</li><li><code>statusMap</code>: A <code>WeakMap</code> keyed by response class, valued by status code.</li></ul><hr><h6>HTTP Serializer <span>(<a href="https://github.com/fortunejs/fortune/blob/master/lib/net&#x2F;http_serializer.js"><em>net&#x2F;http_serializer.js</em></a>)</span></h6><h2 id="httpserializer"><span class="class">class</span> <!--
        --><!--
        --><!--
        -->HttpSerializer<!--
        --><!--
        --><!--
        --><!--
        --><!--
        --><!--
      --><a href="#httpserializer" class="anchor">#</a></h2><p><strong>Node.js only</strong>: <code>HttpSerializer</code> is an abstract base class containing methods to be implemented.</p><h2 id="httpserializer-constructor"><span class="class">new</span> HttpSerializer<!--
        --><!--
        --><!--
        --><!--
          -->()<!--
        --><!--
        --><!--
      --><a href="#httpserializer-constructor" class="anchor">#</a></h2><p>The <code>HttpSerializer</code> should not be instantiated directly, since the constructor function accepts dependencies. The keys which are injected are:</p><ul><li><code>methods</code>: same as static property on Fortune class.</li><li><code>errors</code>: same as static property on Fortune class.</li><li><code>keys</code>: an object which enumerates reserved constants for record type definitions.</li><li><code>recordTypes</code>: an object which enumerates record types and their definitions.</li><li><code>castValue</code>: a function with the signature (<code>value</code>, <code>type</code>, <code>options</code>), useful for casting arbitrary values to a particular type.</li><li><code>options</code>: the options passed to the serializer.</li><li><code>adapter</code>: a reference to the adapter instance.</li><li><code>message</code>: a function with the signature (<code>id</code>, <code>language</code>, <code>data</code>).</li><li><code>Promise</code>: the Promise implementation.</li></ul><p>These keys are accessible on the instance (<code>this</code>).</p><h2 id="httpserializer-processrequest"><!--
        --><!--
        --><!--
        --><!--
        -->HttpSerializer.<span class="key">processRequest</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="Object">contextRequest</span>, <span class="parameter" title="Object">request</span>, <span class="parameter" title="Object">response</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise | Object</span><!--
        --><!--
      --><a href="#httpserializer-processrequest" class="anchor">#</a></h2><p>This method is run first, and it is optional to implement. The default implementation is typically used so that it may interoperate with other serializers. The purpose is typically to read and mutate the request before anything else happens. For example, it can handle URI routing and query string parsing. The arguments that it accepts beyond the required <code>contextRequest</code> are the <code>request</code> and <code>response</code> arguments from the Node.js HTTP listener.</p><p>It should return either the context request or a promise that resolves to the context request. <em>The expectation is that the request is mutated except for the payload</em>, which should be handled separately.</p><h2 id="httpserializer-processresponse"><!--
        --><!--
        --><!--
        --><!--
        -->HttpSerializer.<span class="key">processResponse</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="Object">contextResponse</span>, <span class="parameter" title="Object">request</span>, <span class="parameter" title="Object">response</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise | Object</span><!--
        --><!--
      --><a href="#httpserializer-processresponse" class="anchor">#</a></h2><p>This gets run last. The purpose is typically to read and mutate the response at the very end, for example, stringifying an object to be sent over the network. The arguments that it accepts beyond the required <code>contextResponse</code> are the <code>request</code> and <code>response</code> arguments from the Node.js HTTP listener.</p><p>It should return either the context response or a promise that resolves to the context response. <em>The expectation is that there is a key on the context response, <code>payload</code>, which is either a string or a buffer</em>, or else Node.js doesn&#39;t know how to respond.</p><h2 id="httpserializer-parsepayload"><!--
        --><!--
        --><!--
        --><!--
        -->HttpSerializer.<span class="key">parsePayload</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="Object">contextRequest</span>, <span class="parameter" title="Object">request</span>, <span class="parameter" title="Object">response</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise | an array of Objects</span><!--
        --><!--
      --><a href="#httpserializer-parsepayload" class="anchor">#</a></h2><p>Parse a request payload for creating or updating records. This method should return either an array of records as expected from the <code>adapter.create</code> method, or an array of update object as expected from the <code>adapter.update</code>. method. It may also mutate the context request object.</p><h2 id="httpserializer-mediatype"><span class="class">static</span> <!--
        --><!--
        --><!--
        --><!--
        -->HttpSerializer.<span class="key">mediaType</span><!--
        --><!--
        --><!--
        --><!--
        --><!--
      --><a href="#httpserializer-mediatype" class="anchor">#</a></h2><p>A serializer must have a static property <code>mediaType</code>, which <strong>MUST</strong> be a string.</p><hr><h6>WebSocket <span>(<a href="https://github.com/fortunejs/fortune/blob/master/lib/net&#x2F;websocket_server.js"><em>net&#x2F;websocket_server.js</em></a><a href="https://github.com/fortunejs/fortune/blob/master/lib/net&#x2F;websocket_client.js"><em>net&#x2F;websocket_client.js</em></a><a href="https://github.com/fortunejs/fortune/blob/master/lib/net&#x2F;websocket_request.js"><em>net&#x2F;websocket_request.js</em></a><a href="https://github.com/fortunejs/fortune/blob/master/lib/net&#x2F;websocket_sync.js"><em>net&#x2F;websocket_sync.js</em></a>)</span></h6><h2 id="fortune.net-ws"><!--
        --><!--
        --><!--
        --><!--
        -->Fortune.net.<span class="key">ws</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="Fortune">instance</span>, <span class="parameter" title="Function">[change]</span>, <span class="parameter" title="Object">[options]</span>, <span class="parameter" title="Function">[callback]</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Server</span><!--
        --><!--
      --><a href="#fortune.net-ws" class="anchor">#</a></h2><p><strong>Node.js only</strong>: This function returns a WebSocket server that implements the Fortune wire protocol. The options are the same as those documented in the documentation for the <a href="https://github.com/websockets/ws/blob/master/doc/ws.md"><code>ws</code> module</a>. There is an additional option which this server uses, <code>useIPC</code>, which may be set to <code>true</code> to enable the IPC functionality.</p><p>The wire protocol is based on <a href="http://msgpack.org">MessagePack</a>. The client may send two kinds of requests: setting state within the connection, and making a request to the Fortune instance. Each client request <strong>MUST</strong> include an ID for correlating a response to a request. For example, requesting a state change would look like:</p><pre><code class="lang-js">{ id: 'xxx', <span class="hljs-keyword">state</span>: { ... } } // MessagePack encoded.
</code></pre><p>The format is identical in the response for a state change.</p><p>Making a request to the instance is similar, and has the same parameters as the <a href="#fortune-request"><code>request</code> method</a>:</p><pre><code class="lang-js">{ <span class="hljs-string">id:</span> <span class="hljs-string">'xxx'</span>, <span class="hljs-string">request:</span> { ... } } <span class="hljs-comment">// MessagePack encoded.</span>
</code></pre><p>When a request succeeds, the client receives the response like so:</p><pre><code class="lang-js">{ <span class="hljs-string">id:</span> <span class="hljs-string">'xxx'</span>, <span class="hljs-string">response:</span> { ... } } <span class="hljs-comment">// MessagePack encoded.</span>
</code></pre><p>The <code>change</code> callback function gets invoked either when a change occurs within the Fortune instance, or when the client requests a state change. If it&#39;s an internal change, it is invoked with the current state and changes, otherwise if it&#39;s a connection state change, it does not have a second argument. For an internal change, the return value of this function determines either what gets sent to the client, which may be falsy to send nothing. For connection state change, the return value should be what gets assigned over the current state. It may also return a Promise. For example:</p><pre><code class="lang-js">function change (<span class="hljs-keyword">state</span>, changes) {
  return new Promise((resolve, reject) =&gt; {
    if (!changes) {
      // Accept only changes <span class="hljs-keyword">to</span> the `isListening` key.
      return resolve({ isListening: Boolean(<span class="hljs-keyword">state</span>.isListening) })
    }
    // Determine what changes should be relayed <span class="hljs-keyword">to</span> the client,
    // based <span class="hljs-keyword">on</span> the current <span class="hljs-keyword">state</span>.
    return resolve(<span class="hljs-keyword">state</span>.isListening ? changes : null)
  })
}
</code></pre><p>The changes are relayed to the client like so:</p><pre><code class="lang-js">{ <span class="hljs-string">changes:</span> { ... } } <span class="hljs-comment">// MessagePack encoded.</span>
</code></pre><p>If any request fails, the client receives a message like so:</p><pre><code class="lang-js">{ <span class="hljs-string">id:</span> <span class="hljs-string">'xxx'</span>, <span class="hljs-string">error:</span> <span class="hljs-string">'...'</span> } <span class="hljs-comment">// MessagePack encoded.</span>
</code></pre><p>The returned <code>Server</code> object has an additional key <code>stateMap</code>, which is a <code>WeakMap</code> keyed by WebSocket connection, and valued by connection state. This may be useful for external connection handlers.</p><p><em>Note that by default, this is a single-threaded implementation</em>. In order to scale past a single instance, inter-process communication (IPC) is necessary. When a server is started within a worker process using the <code>cluster</code> module, it emits and responds to change events. How the messaging is orchestrated is not handled by Fortune.js itself, instead it is left to the user.</p><h2 id="fortune.net-client"><!--
        --><!--
        --><!--
        --><!--
        -->Fortune.net.<span class="key">client</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="WebSocket">client</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Object</span><!--
        --><!--
      --><a href="#fortune.net-client" class="anchor">#</a></h2><p>Given a W3C WebSocket client, return an object that contains Fortune instance methods <code>request</code>, <code>find</code>, <code>create</code>, <code>update</code>, <code>delete</code>, and a new method <code>state</code> for changing connection state. This is merely a convenience method that wraps around <code>fortune.net.request</code>. For example:</p><pre><code class="lang-js">// https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
var client =<span class="hljs-built_in"> new </span>WebSocket(url, protocols)
var remote = fortune.net.client(client)

// `remote` is an object containing Fortune<span class="hljs-built_in"> instance </span>methods,<span class="hljs-built_in"> and </span>the
// `state` method.
remote.request(...)
remote.state(...)
</code></pre><h2 id="fortune.net-request"><!--
        --><!--
        --><!--
        --><!--
        -->Fortune.net.<span class="key">request</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="WebSocket">client</span>, <span class="parameter" title="Object">[options]</span>, <span class="parameter" title="Object">[state]</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Promise</span><!--
        --><!--
      --><a href="#fortune.net-request" class="anchor">#</a></h2><p>Given a W3C WebSocket client, send a request using the Fortune wire protocol, and get a response back as a Promise. This will not create a client, it needs to be created externally, and this method will automatically wait if it is not connected yet. For example:</p><pre><code class="lang-js"><span class="hljs-comment">// https://developer.mozilla.org/en-US/docs/Web/API/WebSocket</span>
<span class="hljs-selector-tag">var</span> client = new WebSocket(url, protocols)
fortune<span class="hljs-selector-class">.net</span><span class="hljs-selector-class">.request</span>(client, options)
</code></pre><p>The <code>options</code> object is exactly the same as that defined by <code>fortune.request</code>, and the <code>state</code> object is an arbitrary object to send to request a state change. Either <code>options</code> or <code>state</code> must be passed.</p><h2 id="fortune.net-sync"><!--
        --><!--
        --><!--
        --><!--
        -->Fortune.net.<span class="key">sync</span><!--
        --><!--
        --><!--
        --><!--
          -->(<span class="parameter" title="WebSocket">client</span>, <span class="parameter" title="Fortune">instance</span>, <span class="parameter" title="Function">[merge]</span>)<!--
        --><!--
        --><!--
        --><span class="arrow">â‡’</span><!--
        --><span class="return">Function</span><!--
        --><!--
      --><a href="#fortune.net-sync" class="anchor">#</a></h2><p>Given a W3C WebSocket client and an instance of Fortune, try to synchronize records based on the <code>changes</code> data pushed from the server. This function returns the event listener function.</p><p>When a sync is completed, it emits the <code>sync</code> event with the changes data, or the <code>failure</code> event if something failed.</p><p>Optionally, a <code>merge</code> function may be passed, which accepts one argument, the remote changes, and is expected to return the changes to accept. This is useful for preventing remote changes from overriding local changes.</p><hr></div><footer>&copy; 2016 &nbsp;&mdash;&nbsp; <a href="https://raw.githubusercontent.com/fortunejs/fortune/master/LICENSE">MIT License</a></footer></article><nav><div><h4>Docs <span class="version">(v4.2.3)</span></h4><ul><li><a href="../"><span>Readme</span></a></li><li><a href="../api/"><span>API Reference</span></a></li><li><a href="../plugins/"><span>Plugins</span></a></li><li><a href="../changelog/"><span>Changelog</span></a></li></ul><h4>Fortune</h4><ul><li><a href="../api/#fortune"><span>Fortune</span></a></li><li><a href="../api/#fortune-constructor"><span>constructor</span></a></li><li><a href="../api/#fortune-request"><span>request</span></a></li><li><a href="../api/#fortune-find"><span>find</span></a></li><li><a href="../api/#fortune-create"><span>create</span></a></li><li><a href="../api/#fortune-update"><span>update</span></a></li><li><a href="../api/#fortune-delete"><span>delete</span></a></li><li><a href="../api/#fortune-connect"><span>connect</span></a></li><li><a href="../api/#fortune-disconnect"><span>disconnect</span></a></li></ul><h4>Adapter</h4><ul><li><a href="../api/#adapter"><span>Adapter</span></a></li><li><a href="../api/#adapter-constructor"><span>constructor</span></a></li><li><a href="../api/#adapter-connect"><span>connect</span></a></li><li><a href="../api/#adapter-disconnect"><span>disconnect</span></a></li><li><a href="../api/#adapter-create"><span>create</span></a></li><li><a href="../api/#adapter-find"><span>find</span></a></li><li><a href="../api/#adapter-update"><span>update</span></a></li><li><a href="../api/#adapter-delete"><span>delete</span></a></li><li><a href="../api/#adapter-begintransaction"><span>beginTransaction</span></a></li><li><a href="../api/#adapter-endtransaction"><span>endTransaction</span></a></li><li><a href="../api/#adapter-applyoperators"><span>applyOperators</span></a></li></ul><h4>HTTP Server</h4><ul><li><a href="../api/#fortune.net-http"><span>http</span></a></li></ul><h4>HTTP Serializer</h4><ul><li><a href="../api/#httpserializer"><span>HttpSerializer</span></a></li><li><a href="../api/#httpserializer-constructor"><span>constructor</span></a></li><li><a href="../api/#httpserializer-processrequest"><span>processRequest</span></a></li><li><a href="../api/#httpserializer-processresponse"><span>processResponse</span></a></li><li><a href="../api/#httpserializer-parsepayload"><span>parsePayload</span></a></li><li><a href="../api/#httpserializer-mediatype"><span>mediaType</span></a></li></ul><h4>WebSocket</h4><ul><li><a href="../api/#fortune.net-ws"><span>ws</span></a></li><li><a href="../api/#fortune.net-client"><span>client</span></a></li><li><a href="../api/#fortune.net-request"><span>request</span></a></li><li><a href="../api/#fortune.net-sync"><span>sync</span></a></li></ul><hr></div></nav></main><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.perfect-scrollbar/0.6.12/js/perfect-scrollbar.min.js"></script><script>void function () {
  var sidebar = document.querySelector('nav > div')
  Ps.initialize(sidebar)
}()</script>