<!DOCTYPE html><!--

This page is automatically generated. See:
https://github.com/fortunejs/fortune/tree/master/website

--><meta charset="utf-8"><title>Guide</title><link rel="icon" href="../assets/piggu.png"><link rel="stylesheet" href="../assets/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.perfect-scrollbar/0.6.12/css/perfect-scrollbar.min.css"><header><div><a href="../"><img src="../assets/fortune_logo.svg" alt="Fortune.js" class="logo-type"></a><a href="https://github.com/fortunejs/fortune" class="corner">GitHub<span> Repository</span></a></div></header><main><article><h1>Guide</h1><p><em>This guide assumes familiarity with Node.js, JavaScript, and databases, and is intended to show how to use Fortune.js effectively.</em></p><p>Fortune.js is a database abstraction layer for Node.js and web browsers. It makes assumptions about the data model in order to build features on top of those assumptions:</p><ul><li><strong>Inverse relationship updates</strong>: when using links in the definition of a record type, Fortune.js will automatically write the other side of the link.</li><li><strong>Referential integrity</strong>: Fortune.js ensures that all links must be valid at the application level.</li><li><strong>Type validation</strong>: fields are guaranteed to belong to a single type.</li><li><strong>Adapter interface</strong>: any database driver that can implement the Adapter abstract base class can work with Fortune.js.</li></ul><p>The only required input of Fortune.js are <em>record types</em>, which are analogous to a <code>struct</code> in C-like languages. Record types guarantee that fields must belong to a single type or that they are links. The valid types are native JavaScript types including <code>Buffer</code> from Node.js, and custom types may extend one of the native types. A link must refer to an ID belonging to a single record type. Both types and links may be defined as arrays or singular values.</p><p>Links in record type fields are just primitive values that correspond to the ID of a record in a collection. What is special about links is that Fortune.js automatically manages both sides of the relationship. Writing a link on a record will cause other records to be written as well.</p><p>Here is a basic example of record type definitions, which may model a micro-blogging service:</p><pre><code class="lang-js"><span class="hljs-keyword">const</span> fortune = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fortune'</span>)

<span class="hljs-keyword">const</span> recordTypes = {
  <span class="hljs-attr">post</span>: {
    <span class="hljs-attr">text</span>: <span class="hljs-built_in">String</span>,
    <span class="hljs-attr">createdAt</span>: <span class="hljs-built_in">Date</span>,
    <span class="hljs-attr">replies</span>: [ <span class="hljs-built_in">Array</span>(<span class="hljs-string">'post'</span>), <span class="hljs-string">'parent'</span> ],
    <span class="hljs-attr">parent</span>: [ <span class="hljs-string">'post'</span>, <span class="hljs-string">'replies'</span> ],
    <span class="hljs-attr">author</span>: [ <span class="hljs-string">'user'</span>, <span class="hljs-string">'posts'</span> ]
  },
  <span class="hljs-attr">user</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-built_in">String</span>,
    <span class="hljs-attr">password</span>: Buffer,
    <span class="hljs-attr">salt</span>: Buffer,
    <span class="hljs-attr">posts</span>: [ <span class="hljs-built_in">Array</span>(<span class="hljs-string">'post'</span>), <span class="hljs-string">'author'</span> ],
    <span class="hljs-attr">following</span>: [ <span class="hljs-built_in">Array</span>(<span class="hljs-string">'user'</span>), <span class="hljs-string">'followers'</span> ],
    <span class="hljs-attr">followers</span>: [ <span class="hljs-built_in">Array</span>(<span class="hljs-string">'user'</span>), <span class="hljs-string">'following'</span> ]
  }
}

<span class="hljs-keyword">const</span> store = fortune(recordTypes)
</code></pre><p>This is already very close to a working web application. The rest of this guide will focus on all of the parts which are relevant for building this hypothetical application.</p><h2 id="adapter-interface">Adapter Interface<a class="anchor" href="#adapter-interface" title="Link to this section “Adapter Interface”">#</a></h2><p>By default, Fortune.js uses an in-memory database. While this is fine for development purposes, it will not scale beyond a single thread nor will it persist data. What Fortune.js provides is an abstract base class for dealing with the database called the <code>Adapter</code>. To use an adapter, it must be specified. For example, using the Postgres adapter:</p><pre><code class="lang-js"><span class="hljs-keyword">const</span> pgAdapter = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fortune-postgres'</span>)

<span class="hljs-keyword">const</span> adapter = [ pgAdapter, {
  <span class="hljs-comment">// In this example, the Postgres adapter requires the connection URL.</span>
  url: <span class="hljs-string">'postgres://postgres@localhost:5432/app_db'</span>
} ]

<span class="hljs-keyword">const</span> store = fortune(recordTypes, { adapter })
</code></pre><p>The adapter must implement the create, find, update, and delete methods. The find method specifies basic querying options, such as sorting, matching, ranges, existence, sparse fields, limit and offset. An adapter may optionally implement more adapter-specific queries, as well as transactions. In this case, the Postgres adapter implements transactions, so that each request to Fortune.js is atomic.</p><h2 id="internationalization">Internationalization<a class="anchor" href="#internationalization" title="Link to this section “Internationalization”">#</a></h2><p>In most real world applications, data must be validated for errors. Fortune.js exposes its own error classes and the <code>message</code> function to help translate errors to status codes and localized text. All of the error messages that Fortune.js uses internally and exposes to clients may be localized, and custom error messages may be specified like so:</p><pre><code class="lang-js"><span class="hljs-keyword">const</span> { message } = fortune

<span class="hljs-comment">// Add application error messages in English (default language).</span>
<span class="hljs-comment">// More languages can be defined as keys on the `message` function.</span>
<span class="hljs-built_in">Object</span>.assign(message.en, {
  <span class="hljs-string">'InvalidAuthorization'</span>: <span class="hljs-string">'The given user and/or password is invalid.'</span>,
  <span class="hljs-string">'InvalidPermission'</span>: <span class="hljs-string">'You do not have permission to do that.'</span>,
  <span class="hljs-string">'MissingField'</span>: <span class="hljs-string">'The required field "{field}" is missing.'</span>
})
</code></pre><h2 id="input-and-output-hooks">Input and Output Hooks<a class="anchor" href="#input-and-output-hooks" title="Link to this section “Input and Output Hooks”">#</a></h2><p>Input and output hooks are user-defined functions which are run before writing a record, and after reading a record. They exist merely for convenience, one could also override the <code>request</code> method to implement the same functionality. These hooks are intended to isolate business logic, and any errors thrown here may be mapped to status codes. They may be specified like so:</p><pre><code class="lang-js"><span class="hljs-keyword">const</span> hooks = {
  <span class="hljs-attr">user</span>: [ userInput, userOutput ],
  <span class="hljs-attr">post</span>: [ postInput ]
}

<span class="hljs-keyword">const</span> store = fortune(recordTypes, { hooks })
</code></pre><p>All of the arguments for the I/O hooks may be mutated. Any custom errors thrown will be displayed to client, while operational errors will be hidden (native errors such as <code>Error</code>).</p><p>For example, dealing with input for the <code>user</code> record type, a variety of authorization cases need to be handled. When creating a user, the name and password fields must be checked and the password must be encrypted, while updating and deleting require an authorization check.</p><pre><code class="lang-js"><span class="hljs-keyword">const</span> { methods, <span class="hljs-attr">errors</span>: { BadRequestError } } = fortune

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">userInput</span> (<span class="hljs-params">context, record, update</span>) </span>{
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">request</span>: { method, <span class="hljs-attr">meta</span>: { language } } } = context

  <span class="hljs-keyword">switch</span> (method) {
  <span class="hljs-keyword">case</span> methods.create:
    <span class="hljs-comment">// Check for required fields.</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> field <span class="hljs-keyword">of</span> [ <span class="hljs-string">'name'</span>, <span class="hljs-string">'password'</span> ])
      <span class="hljs-keyword">if</span> ((!field <span class="hljs-keyword">in</span> record)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadRequestError(
        message(<span class="hljs-string">'MissingField'</span>, language, { field }))

    <span class="hljs-keyword">const</span> { name, password } = record
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({ name }, makePassword(password))

  <span class="hljs-keyword">case</span> methods.update:
    <span class="hljs-keyword">return</span> validateUser(context, update.id).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (update.replace) {
        <span class="hljs-comment">// Only allow updates to name and password.</span>
        <span class="hljs-keyword">const</span> { <span class="hljs-attr">replace</span>: { name, password } } = update
        update.replace = { name }
        <span class="hljs-keyword">if</span> (password) <span class="hljs-built_in">Object</span>.assign(update.replace, makePassword(password))
      }

      <span class="hljs-comment">// Only allow push/pull updates to follow and unfollow.</span>
      <span class="hljs-keyword">if</span> (update.push) update.push = { <span class="hljs-attr">following</span>: update.push.following }
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (update.pull) update.pull = { <span class="hljs-attr">following</span>: update.pull.following }
    })

  <span class="hljs-keyword">case</span> methods.delete:
    <span class="hljs-keyword">return</span> validateUser(context, record.id)
  }
}
</code></pre><p>The password hashing function is an implementation detail. In this example, a hash function is used for the sake of simplicity, though a key derivation function or stronger should be used in real applications.</p><pre><code class="lang-js"><span class="hljs-keyword">const</span> hashAlgorithm = <span class="hljs-string">'SHA256'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makePassword</span> (<span class="hljs-params">string</span>) </span>{
  <span class="hljs-keyword">const</span> salt = crypto.randomBytes(<span class="hljs-number">32</span>)
  <span class="hljs-keyword">const</span> password = crypto.createHash(hashAlgorithm)
    .update(salt).update(<span class="hljs-string">''</span> + string).digest()

  <span class="hljs-keyword">return</span> { salt, password }
}
</code></pre><p>The <code>validateUser</code> function is an implementation detail which may be shared across other hooks. For stateless protocols such as HTTP, the request parameters should contain all of the information necessary to make the request, including authorization credentials.</p><pre><code class="lang-js"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>)

<span class="hljs-keyword">const</span> { <span class="hljs-attr">errors</span>: { UnauthorizedError, ForbiddenError } } = fortune

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateUser</span> (<span class="hljs-params">context, userId</span>) </span>{
  <span class="hljs-keyword">const</span> {
    <span class="hljs-attr">request</span>: { <span class="hljs-attr">meta</span>: { <span class="hljs-attr">headers</span>: { authorization }, language } },
    <span class="hljs-attr">response</span>: { meta }
  } = context

  <span class="hljs-comment">// Parse HTTP Basic Access Authentication.</span>
  <span class="hljs-keyword">const</span> [ userId, password ] = atob(authorization.split(<span class="hljs-string">' '</span>)[<span class="hljs-number">1</span>]).split(<span class="hljs-string">':'</span>)

  <span class="hljs-keyword">if</span> (!userId || !password) {
    <span class="hljs-keyword">if</span> (!meta.headers) meta.headers = {}
    meta.headers[<span class="hljs-string">'WWW-Authenticate'</span>] = <span class="hljs-string">'Basic realm="App name"'</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnauthorizedError(message(<span class="hljs-string">'InvalidAuthorization'</span>, language))
  }

  <span class="hljs-keyword">const</span> options = { <span class="hljs-attr">fields</span>: { <span class="hljs-attr">password</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">salt</span>: <span class="hljs-literal">true</span> } }

  <span class="hljs-keyword">return</span> store.adapter.find(<span class="hljs-string">'user'</span>, [ userId ], options).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> [ user ] = result
    <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> ForbiddenError(message(<span class="hljs-string">'InvalidPermission'</span>, language))

    <span class="hljs-keyword">if</span> (!user || (userId &amp;&amp; userId !== user.id)) <span class="hljs-keyword">throw</span> error

    <span class="hljs-keyword">const</span> hash = crypto.createHash(hashAlgorithm)
      .update(user.salt).update(password).digest()

    <span class="hljs-comment">// Prefer a constant-time equality check, this is not secure.</span>
    <span class="hljs-keyword">if</span> (!hash.equals(user.password)) <span class="hljs-keyword">throw</span> error

    <span class="hljs-keyword">return</span> user
  })
}
</code></pre><p>When reading a user, the password and salt must not be exposed. This can be done in the output hook:</p><pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">userOutput</span> (<span class="hljs-params">context, record</span>) </span>{
  <span class="hljs-keyword">delete</span> record.password
  <span class="hljs-keyword">delete</span> record.salt
}
</code></pre><p>The <code>post</code> type only needs to check for validity and whitelist fields that may be written.</p><pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postInput</span> (<span class="hljs-params">context, record, update</span>) </span>{
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">request</span>: { method, <span class="hljs-attr">meta</span>: { language } } } = context

  <span class="hljs-keyword">switch</span> (method) {
  <span class="hljs-keyword">case</span> methods.create:
    <span class="hljs-keyword">const</span> { text, parent } = record
    <span class="hljs-keyword">return</span> validateUser(context).then(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> ({
      text, parent, <span class="hljs-attr">createdAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), <span class="hljs-attr">author</span>: user.id
    }))

  <span class="hljs-keyword">case</span> methods.update:
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ForbiddenError(message(<span class="hljs-string">'InvalidPermissions'</span>, language))

  <span class="hljs-keyword">case</span> methods.delete:
    <span class="hljs-keyword">return</span> validateUser(context, record.author)
  }
}
</code></pre><h2 id="networking">Networking<a class="anchor" href="#networking" title="Link to this section “Networking”">#</a></h2><p>All networking is external to Fortune.js. It makes no assumption that there is even a network at all. This makes it feasible to write applications which are decoupled from the network protocol.</p><p>There is a <code>fortune-http</code> package which maps requests and responses from the listener function arguments in Node.js to Fortune.js. What it does is implement relevant parts of the HTTP protocol such as content negotiation, status codes, caching and encoding. In the example above, error classes are used, and each error class maps to a status code.</p><p>A few basic serializers are included. To use it:</p><pre><code class="lang-js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>)
<span class="hljs-keyword">const</span> fortuneHTTP = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fortune-http'</span>)

<span class="hljs-keyword">const</span> listener = fortuneHTTP(store, {
  <span class="hljs-comment">// The order specifies priority of media type negotiation.</span>
  serializers: [
    fortuneHTTP.JsonSerializer,
    fortuneHTTP.HtmlSerializer,
    fortuneHTTP.FormDataSerializer,
    fortuneHTTP.FormUrlEncodedSerializer
  ]
})

<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span>
  listener(request, response)
  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> { <span class="hljs-comment">/* error logging */</span> }))

server.listen(<span class="hljs-number">1337</span>)
</code></pre><p>There is also a <code>fortune-ws</code> package, which may be useful for real-time updates. It implements a wire protocol that uses MessagePack as a serialization format.</p><p>Suppose that new posts from users who are followed should be sent. The client must initiate a state change containing users to follow, so that the server knows which posts to send.</p><pre><code class="lang-js"><span class="hljs-keyword">const</span> fortuneWS = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fortune-ws'</span>)

<span class="hljs-keyword">const</span> options = { <span class="hljs-attr">port</span>: <span class="hljs-number">1337</span> }
<span class="hljs-keyword">const</span> server = fortuneWS(store, (state, changes) =&gt; {
  <span class="hljs-comment">// Whitelist state changes.</span>
  <span class="hljs-keyword">if</span> (!changes) <span class="hljs-keyword">return</span> { <span class="hljs-attr">users</span>: <span class="hljs-built_in">Array</span>.isArray(state.users) ? state.users : [] }

  <span class="hljs-comment">// Only send new posts from users that are being followed.</span>
  <span class="hljs-keyword">if</span> (changes[methods.create] &amp;&amp; changes[methods.create].post) {
    <span class="hljs-keyword">const</span> post = state.users ? changes[methods.create].post
      .filter(<span class="hljs-function"><span class="hljs-params">post</span> =&gt;</span> ~state.users.indexOf(post.author)) : []

    <span class="hljs-keyword">if</span> (post.length) <span class="hljs-keyword">return</span> { [methods.create]: { post } }
  }
}, options)
</code></pre><p>A web client can listen for changes:</p><pre><code class="lang-js"><span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> WebSocket(...)
<span class="hljs-keyword">const</span> users = [ ... ]

fortuneWS.request(client, <span class="hljs-literal">null</span>, { users })
.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> fortuneWS.sync(client, store))
</code></pre><h2 id="philosophy">Philosophy<a class="anchor" href="#philosophy" title="Link to this section “Philosophy”">#</a></h2><p>Most web applications are like skins around databases. Fortune.js provides an abstraction around core functionality of web applications. It is designed as a library which adds useful features on top of databases.</p><p>It avoids the Object-Relational or Object-Document Mapping problem by not dealing with <em>objects</em> in the Object-Oriented Programming sense. Records in Fortune.js do not inherit any classes and are just plain data structures.</p><p>It targets Node.js and web browsers with the same codebase, since the same concepts apply in both environments.</p><footer>&copy; 2016 &nbsp;&mdash;&nbsp; <a href="https://raw.githubusercontent.com/fortunejs/fortune/master/LICENSE">MIT License</a></footer></article><nav><div><h4>Docs <span class="version">(v5.0.2)</span></h4><ul><li><a href="../"><span>Readme</span></a></li><li><a href="../guide/"><span>Guide</span></a></li><li><a href="../api/"><span>API Reference</span></a></li><li><a href="../plugins/"><span>Plugins</span></a></li><li><a href="../concepts/"><span>Concepts</span></a></li><li><a href="../changelog/"><span>Changelog</span></a></li></ul><h4>Fortune</h4><ul><li><a href="../api/#fortune"><span>Fortune</span></a></li><li><a href="../api/#fortune-constructor"><span>constructor</span></a></li><li><a href="../api/#fortune-request"><span>request</span></a></li><li><a href="../api/#fortune-find"><span>find</span></a></li><li><a href="../api/#fortune-create"><span>create</span></a></li><li><a href="../api/#fortune-update"><span>update</span></a></li><li><a href="../api/#fortune-delete"><span>delete</span></a></li><li><a href="../api/#fortune-connect"><span>connect</span></a></li><li><a href="../api/#fortune-disconnect"><span>disconnect</span></a></li></ul><h4>Adapter</h4><ul><li><a href="../api/#adapter"><span>Adapter</span></a></li><li><a href="../api/#adapter-constructor"><span>constructor</span></a></li><li><a href="../api/#adapter-connect"><span>connect</span></a></li><li><a href="../api/#adapter-disconnect"><span>disconnect</span></a></li><li><a href="../api/#adapter-create"><span>create</span></a></li><li><a href="../api/#adapter-find"><span>find</span></a></li><li><a href="../api/#adapter-update"><span>update</span></a></li><li><a href="../api/#adapter-delete"><span>delete</span></a></li><li><a href="../api/#adapter-begintransaction"><span>beginTransaction</span></a></li><li><a href="../api/#adapter-endtransaction"><span>endTransaction</span></a></li><li><a href="../api/#adapter-applyoperators"><span>applyOperators</span></a></li></ul><h4>HTTP Server</h4><ul><li><a href="../api/#fortunehttp-createlistener"><span>createListener</span></a></li></ul><h4>HTTP Serializer</h4><ul><li><a href="../api/#httpserializer"><span>HttpSerializer</span></a></li><li><a href="../api/#httpserializer-constructor"><span>constructor</span></a></li><li><a href="../api/#httpserializer-processrequest"><span>processRequest</span></a></li><li><a href="../api/#httpserializer-processresponse"><span>processResponse</span></a></li><li><a href="../api/#httpserializer-parsepayload"><span>parsePayload</span></a></li><li><a href="../api/#httpserializer-mediatype"><span>mediaType</span></a></li></ul><h4>WebSocket</h4><ul><li><a href="../api/#fortunews-createserver"><span>createServer</span></a></li><li><a href="../api/#fortunews-request"><span>request</span></a></li><li><a href="../api/#fortunews-sync"><span>sync</span></a></li></ul><hr></div></nav></main><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.perfect-scrollbar/0.6.12/js/perfect-scrollbar.min.js"></script><script>Ps.initialize(document.querySelector('nav > div'))</script>